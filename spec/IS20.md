# Token Standard Spec

The InfinitySwap (IS20) token standard is based on the Ethereum ERC20 standard and is compatible
with the DIP20 token standard.

The main additions to the DIP20 are [transaction notification](#Transaction notifications)
and [cycle auction](#Cycle auctions) methods. All other changes in comparison to DIP20 marked in
this document with `DIP20 compatability` note.

# Rational

ERC20 is a well established and widely used token standard in Ethereum ecosystem. Internet Computer
environment introduces a few changes though, that do not allow using ERC20 tokens in IC as is:

1. Reverse gas model, requiring the token smart contracts (canisters) to pay for all incoming requests.
   This makes it possible to drain the canister of cycles with a lot of empty update calls.
2. Asynchronous nature of all inter-canister calls make it impossible to use ERC20 tokens in operations
   like AMM flash swaps.

To deal with the first issue, IS20 adds the notion of transaction fee. This fee is set by the canister
owner and is collected on each transaction. A portion of the fee is then used for cycle auctions,
providing decentralized method to provide cycles for the canister.

# Message inspection

To prevent possible DDOS attacks, the IS20 allows any update methods to reject ingress messages if the request seems
unreasonable. In this case IC will return `403` error to the caller.

The default implementation introduces following checks:
* all methods that are available only for the owner are rejected, if the caller is not the owner
* all transaction methods are rejected, if the calling user does not have any balance
* cycles auction can be run only by the owner or by any of the cycle bidders
* notify call can be made only if the given notification id is pending

# History limit

The stored transaction history can be limited to some value. The older transactions than can be removed
from the storage and be forgotten about. If such transactions are queried, an empty response is
produced.

The default implementation has the history length limit of `1 000 000` entries.

# API specification

## Data Structures

1. Metadata: basic token information

```
type Metadata = {
   name : text; // token name
   symbol : text; // token symbol
   decimals : nat8; // token decimal
   totalSupply : nat; // token total supply
   owner : principal; // token owner
   logo : text; // base64 encoded logo or logo url
   fee : nat; // fee for update calls
}
```

2. TxError: error response for transaction related methods.

```
type TxError = variant {
  InsufficientAllowance;
  InsufficientBalance;
  Unauthorized;
  AmountTooSmall,
  NotificationFailed;
  AlreadyNotified;
  TransactionDoesNotExist;
};
```

DIP20 compatibility: DIP20 doesn't include error types related to the notifications (`NotificationFailed`
, `AlreadyNotified` and `TransactionDoesNotExist`), as it does not have the notification mechanism. These errors must
only be returned from the `notify` and `transfer_and_nofity` methods for the implementation to be compatible with DIP20.
Default implementation follows this rule.

`AmountTooSmall` is also not part of DIP20 spec, but it only be returned by IS20 method `transfer_include_fee`.

3. TxRecord: transaction history record

```
type Operation = variant {
  Approve;
  Burn;
  Mint;
  Auction;
  Transfer;
  TransferFrom;
};

type TransactionStatus = variant {
  Failed;
  Succeeded
};

type TxRecord = record {
  to : principal;
  fee : nat;
  status : TransactionStatus;
  from : principal;
  operation : Operation;
  timestamp : int;
  caller : opt principal;
  index : nat;
  amount : nat;
};
```

`caller` in TxRecord is optional and only need to be non-empty for `transferFrom` calls.

## 2. Basic Interfaces

### Update calls

The update calls described in this section might choose to charge `fee` amount of tokens to prevent DDoS attack, this is
necessary because of the reverse gas model of the IC. All update functions are allowed to trap, instead of returning an
error in order to take advantage of the canisters automatic, atomic state rollback.

#### transfer

Transfers `value` amount of tokens to user `to`, returns a `TxReceipt` which contains the transaction index or an error
message. The balance of the caller is reduced by `value + fee` amount.

To protect the caller from unexpected fee amount change, the optional `fee_limit` parameter can be given. If the
fee to be applied is larger than this value, the transaction will fail with `TxError::FeeExceededLimit` error.

```
update transfer(to: Principal, value: nat, fee_limit: opt nat) : TxReceipt
```

#### transferIncludeFee

Transfers `value` amount to the `to` principal, applying American style fee. This means, that
the recipient will receive `value - fee`, and the sender account will be reduced exactly by `value`.

Note, that the `value` cannot be less than the `fee` amount. If the value given is too small,
transaction will fail with `TxError::AmountTooSmall` error.

```
update transferIncludeFee(to: Principal, value: nat) : TxReceipt
```


#### transferFrom

Transfers `value` amount of tokens from user `from` to user `to`, this method allows canister smart contracts to
transfer tokens on your behalf, it returns a `TxReceipt` which contains the transaction index or an error message.

If the `fee` is set, the `from` principal is charged with the fee. In this case, the maximum amount that the caller can
request to transfer is `allowance - fee`.

```
update transferFrom(from: principal, to: principal, value: nat) : TxReceipt
```


#### batchTransfer

Transfers the specified amount to a list of principals. This operation is transactional, meaning that either all or none of the transfers will be executed. The fee (if configured by the token) is taken from every transaction, so total fee amount will be `transfers.len() * fee`.

The balance of the caller is reduced by sum of `value + fee` amount for each transfer. If the total sum of `value + fee` for all transfers,
is less than the `balance` of the caller, the transaction will fail with `TxError::InsufficientBalance` error.

```
update batchTransfer(transfers: vec record {principal, nat}) : enum { ok : vec nat; err : TxError }
```


#### approve

Allows `spender` to withdraw tokens from your account, up to the `value` amount. If it is called again it overwrites the
current allowance with `value`. There is no upper limit for `value`.

```
update approve(spender: principal, value: nat) : TxReceipt
```

### Query calls

#### getTransaction

Returns transaction detail of the transaction identified by `index`. If the `index` is out of range, the execution
traps. Transactions are indexed from zero.

```
query func getTransaction(index: Nat) : TxRecord
```

#### getTransactions

Returns a list of transactions in paginated form. The `who` is optional, if given, only transactions of the `who` are
returned. `count` is the number of transactions to return, `transaction_id` is the transaction index which is used as
the offset of the first transaction to return, any

It returns `PaginatedResult` a struct, which contains `result` which is a list of transactions `Vec<TxRecord>` that meet the requirements of the query,
and `next_id` which is the index of the next transaction to return.

```
query getTransactions(who: opt principal,count: u32, transaction_id: opt u128) : PaginatedResult
```

#### name

Returns the name of the token.

OPTIONAL: the consumers of the API must not expect this value to be present.

```
query name() : text
```

#### logo

Returns the logo of the token as URL link or base64 encoded image (with "base64,..." prefix).

OPTIONAL: the consumers of the API must not expect this value to be present.

```
query logo() : Text
```

#### symbol

Returns the symbol of the token, e.g. "HIX".

OPTIONAL: the consumers of the API must not expect this value to be present.

```
query symbol() : text
```

#### decimals

Returns the decimals of the token, e.g. `8` means to divide the token amount by `100000000` to get its
user representation.

OPTIONAL: the consumers of the API must not expect this value to be present.

```
query decimals() : async nat8
```

#### totalSupply

Returns the total supply of the token.

```
query totalSupply() : nat
```

#### balanceOf

Returns the balance of user `who`.

```
query balanceOf(who: principal) : nat
```

#### allowance

Returns the amount which `spender` is still allowed to withdraw from `owner`.

```
query allowance(owner: principal, spender: principal) : nat
```

#### getMetadata

Returns the metadata of the token.

```
query getMetadata() : Metadata
```

#### historySize

Returns the history size.

```
query historySize() : nat
```

#### owner

Returns the owner of the canister.

```
query owner() -> principal;
```

## Optional interfaces

### Update calls

#### mint

Mint `value` number of new tokens to user `to`, this will increase the token total supply, only `owner` is allowed to
mint new tokens.

```
update mint(to: principal, value: nat): TxReceipt
```

#### burn

Burn `value` number of new tokens from user `from`, this will decrease the token total supply, only `owner` or the
user `from` him/herself can perform this operation.
If `from` is not set, then caller's tokens will be burned.
If `from` is given but method called not by owner, `TxError::Unauthorized` will be returned.
If owner calls this method and `from` is set to `Bob`, then `Bob`'s tokens will be burned.
```
update burn(from: opt principal, value: nat): TxReceipt
```

`aaaaa-aa` is the IC management canister id, it's not a real canister, just an abstraction of system level management
functions, it can be used as blackhole address.

#### setName

Change the name of the token, no return value needed.

```
update setName(name: text)
```

#### setLogo

Change the logo of the token, no return value needed. The `logo` can either be a base64 encoded text of the logo picture
or an URL pointing to the logo picture.

```
update setLogo(logo: text)
```

#### setFee

Set fee to `newFee` for update calls(`approve`, `transfer`, `transferFrom`), no return value needed.

```
update setFee(newFee: nat)
```

#### setFeeTo

Set fee receiver to `newFeeTo` , no return value needed.

```
update setFeeTo(newFeeTo: principal)
```

#### setOwner

Set the owner of the token to `newOwner`, no return value needed.

```
update setOwner(newOwner: principal)
```

### Query calls

#### getUserTransactionAmount

Returns total number of transactions related to the user `who`.

```
query getUserTransactionAmount(who: principal) : async nat
```

## Transaction notifications

IS20 offers a way to reliably inform the receiver of a transaction about the transaction. To do it, we introduce
a `notify` method. It sends an `update` call `transaction_notifiction` to the receiving principal, with the details
about the transaction. A notification can only be sent once for each transaction, preventing possibility of duplicate
call attack.

#### notify

Notifies the transaction receiver about a previously performed transaction.

This method guarantees that a notification for the same transaction id can be sent only once. It allows to use this
method to reliably inform the transaction receiver without danger of duplicate transaction attack.

In case the notification call fails, an `TxError::NotificationFailed` error is returned and the transaction will still
be marked as not notified.

If a notification request is made for a transaction that was already notified, a
`TxError::AlreadyNotified` error is returned.

```
update notify(transactionId: nat) -> TxReceipt
```

#### transferAndNotify

Convenience method to make a transaction and notify the receiver with just one call.

If the notification fails for any reason, the transaction is still completed, but it will be marked as not notified, so
a [notify] call can be done later to re-request the notification of this transaction.

```
update transferAndNotify(to: principal, amount: nat) -> TxReceipt
```

#### Notification call interface

This is the interface for the notification call that is made by the token canister for the receiver canister. This
method is not part of the token canister API.

```
type TransactionNotification = record {
    tx_id: nat;
    from: principal;
    token_id: principal;
    amount: nat;
}

update transaction_notification(notification: TransactionNotification) -> ()
```
